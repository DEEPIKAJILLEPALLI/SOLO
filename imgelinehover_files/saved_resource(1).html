
<!-- saved from url=(0011)about:blank -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function () {
    var pb_blacklist = ["adrunnr","successforyu.clickfunnels.com","fmovies.se","in-365-tagen.info","5000-settimanale.com","shop.mazzugioielli.com","maxigossip.com","lp.yazizim.com","beyourxfriend.com","99tab.com","zzqrt.com","canuck-method.net","bewomenly.com","playnow.guru","datingforyou-48e1.kxcdn.com","trafficnetworkads24.com","sistemadedinerogratis.com","canuckmethodprofit.co","consumerresearchnetwork.com","securemacfix.com","zz3d3.ru","zd1.quebec-bin.com","hot-games4you.xyz","om.elvenar.com","superpccleanup.com","gomediaz.com","judithi.xyz","free.atozmanuals.com","yoursuccess.ravpage.co.il","123hop.ir","quizcliente.pw","aussiemethod.biz","hlpnowp-c.com","picbumper.com","shaneless.com","anacondamonster.com","altrk1.com","health.todaydiets.com","download.weatherblink.com","happyluketh.com","go.ameinfo.com","50kaweek.net","thepornsurvey.com","ofsiite.ru","fulltab.com","1000spins.com","time2play-online.net","vintacars.com","welcome.pussysaga.com","free-desktop-games.com","download.televisionfanatic.com","theprofitsmaker.net","sgad.info","algocashmaster.net","sunmaker.com","topvipdreams.com","watchmygirlfriend.gfpornvideos.com","filesharefanatic.com","safedownloadhub.com","7awlalalam.blogspot.com","tvplusnewtab.com","trendingpatrol.com","moneymorning.com","ifileyou.com","classifiedcanada.ca","firefan.com","methode-binaire.com","letmetell.com","kenduktur.com","getafuk.com","yotraleplahnte.ru","jackpot.88beto.com","pwwysydh.com","search.queryrouter.com","v.lvztxy.com","pussysaga.com","saffamethod.com","prezzonline.com","searchprivacy.website","3d2819216eb4e1035879-7c248de0c99745406e9b749fc86ec3e4.ssl.cf1.rackcdn.com","only2date.com","mysagagame.com","themillionaireinpjs.net","wlt.kd2244.com","quickprivacycheck.com","hotchatdate.com","autotraderbot.com","z1.zedo.com","youlucky2014.com","traffic.getmyads.com","appcloudprotected.com","safensecure.com-allsites3.xyz","newpoptab.com","static.williamhill.com","myhealthyblog.co","greatestmobideals.com","sweetclarity.com","mgid.com","securepccure.com","autopengebygger.com","am15.net","es.reimageplus.com","o2.promos-info.com","it.reimageplus.com","westsluts.com","spinandwin.com-ser.pw","reimageplus.com","vodafone.promos-info.com","vinnmatpengar.se","movie.ienjoyapps.com","love4single.com","origin.getprice.com.au","ohmydating.com","lp.want-to-win.com","yabuletchrome.ru","bamdad.net","gotositenow.com","vcrypt.pw","newtabtv.com","mon.setsu.xyz","youforgottorenewyourhosting.com","zone-telechargement.ws","land.pckeeper.software","ad.adpop-1.com","advancedpctools.com","videos.randolphcountyheraldtribune.com","web-start.org","softreadynow.installupgradenowfreshandforyou.website","uplod.ws","pornhubcasino.com","maxbet.ro","2016prizefeed.com","thevideo.me","wantubad.com","tavanero.com","xcusmy.club","daclips.in","gaymenofporn.online","jackpotcitycasino.com","italian-method.com","getsearchincognito.com","youjustwonprize.com","finanz-nachrichten.me","quizcliente.site","da.reimageplus.com","jkanime.net","britmoneymethod.com","uae.souq.com","ka.azzer.net","safensecure.xyz","8t.hootingrhejkz.online","www6.blinkx.com","wizzcaster.com","comparaison-prix.com","vodlocker.lol","fr.reimageplus.com","free.fromdoctopdf.com","userscloud.com","myprivatesearch.com","fanli90.cn","tutticodicisconto.it","mediadec.com","gogamego.thewhizproducts.com","download.weatherblink.com","free.videodownloadconverter.com","we-are-gamers.com","sesso.communityadult.net","lp.blpmovies.com","search.queryrouter.com","bbb-johannesburg.localspecific.com","lp.blpmovies.com","go.ppixelm.com","r0.ru","sesso.communityadult.net","bbb-johannesburg.localspecific.com","ppixelm.com","cyberguardianspe.info","we-are-gamers.com","loginfaster.com/new","www.alfacart.com","www.foresee.com","mobile-win.com","www.plusnetwork.com","www.amicafarmacia.com","www.ienjoyapps.com","cheapcheap.io","screenaddict.thewhizproducts.com","nova.rambler.ru","free.gamingwonderland.com","p9328ujeiw1.ru","mobilecasinoclub.co.uk","pfhsystem.com","regtuneup.com","theprofitsmaker.net","bodogpromotions.eu","heroesreplay.org","financialsecrets.info","mymoneymakingapp.com","sunmaker.com","888casino-promotions.com","vogliosesso.com","scienceremix.com","allinonedocs.com","arabia.starzplay.com","allirishcasino.com","advancepctools.info","movie.ienjoyapps.com","surveyform001.s3-website-us-east-1.amazonaws.com","mgs188.com","pfhsystem.com","lpeva.com","ddsh8.com","theprofitsmaker.net","b2.ijquery11.com","sporthero.thewhizmarketing.com","securefastmac.tech","seen-on-screen.thewhizmarketing.com","1000spins.com","search.queryrouter.com","pfhsystem.com","reimageplus.com","offer.alibaba.com","searchlistings.org","search.queryrouter.com","search.queryrouter.com","mybinaryoptionsrobot.com","duplicashapp.com","search.queryrouter.com","bestgame.directory","droidclub.net",".rivalo.com","yoursuperprize.com","mediaexplained.com","om.elvenar.com","shinar.club","revitoleczemacream.com","freelotto.com","screenaddict.thewhizproducts.com","download.bringmesports.com/","allinonedocs.com","driver-fixer.com","arabydeal.com","cleanyourcomputertoday.com","arabydeal.com","music.mixplugin.com","1se.info","survey12.com","freesoftwaredlul.com","pldist01.com","ad.adpop-1.com","searchanonymous.net","abrst.pro","muzikfury.thewhizmarketing.com","lp.mbtrx.com","th1.forfun.maxisize-pro.com","watchmygirlfriend.gfpornbox.com","new.freelotto.com","desktoptrack.com","search.queryrouter.com","offer.alibaba.com","1000spins.com","promotions.coral.co.uk","search.queryrouter.com","tbsia.com","tbsia.com","multtaepyo.com","search.queryrouter.com","czechmethod.com","consumerview.co","wayretail.com","72onbase.com","funsafetab.com","search.queryrouter.com","speedyfiledownload.com","driver-fixer.com","arabydeal.com","cleanyourcomputertoday.com","arabydeal.com","music.mixplugin.com","1se.info","survey12.com","freesoftwaredlul.com","pldist01.com","ad.adpop-1.com","searchanonymous.net","abrst.pro","muzikfury.thewhizmarketing.com","lp.mbtrx.com","th1.forfun.maxisize-pro.com","watchmygirlfriend.gfpornbox.com","new.freelotto.com","desktoptrack.com","search.queryrouter.com","offer.alibaba.com","1000spins.com","promotions.coral.co.uk","search.queryrouter.com","tbsia.com","tbsia.com","surveyform001.s3-website-us-east-1.amazonaws.com","mgs188.com","pfhsystem.com","lpeva.com","ddsh8.com","theprofitsmaker.net","quantomcoding.com","sporthero.thewhizmarketing.com","popads.net","onclkds.com","consumerview.co","12kotov.ru","ruhotpair2.fingta.com","easytelevisionaccessnow.com","ahwrd.com","lpeva.com","ppgzf.com","zjstx.com","kituure.xyz","join.pro-gaming-world.com","mackeeperapp.mackeeper.com","tracknotify.com","2075.cdn.beyondhosting.net","idollash.com","ds.moviegoat.com","fulltab.com","rackcdn.com","prestoris.com","adsterra.com","swampssovuuhusp.top","streesusa.info","freesoftwaredlul.com","adreactor.com","a-static.com","codeonclick.com","heheme.com","adf.ly","seen-on-screen.thewhizmarketing.com","openload.co"];
    var pb_whitelist = ["disqus.com","engage.wixapps.net","linkedin.com","google","gmail.com","www.pinterest.com","www.youtube.com","www.facebook.com","myh.godaddy.com"];
    function inject() {
  const originalOpenWndFnKey = "originalOpenFunction";
  const originalWindowOpenFn = window.open;
  const originalCreateElementFn = document.createElement;
  const originalAppendChildFn = HTMLElement.prototype.appendChild;
  const originalCreateEventFn = document.createEvent;
  const windowsWithNames = {};
  let timeSinceCreateAElement = 0;
  let lastCreatedAElement = null;
  let fullScreenOpenTime;
  let winWidth = window.innerWidth;
  let winHeight = window.innerHeight;
  let lastBlockTime;
  const parentRef = window.parent;
  const injectedCode = `(function () {
    var pb_blacklist = ${JSON.stringify(pb_blacklist)};
    var pb_whitelist = ${JSON.stringify(pb_whitelist)};
    ${inject.toString()};
    inject();
  })();`;

  //this should kill an overlay malware, can be found in: popunderjs.com
  Object.defineProperty(window, 'BetterJsPop', {
    value: undefined,
    writable: false
  });

  function getAbsoluteURL(baseURL) {
    if (/^about:blank/i.test(baseURL)) {
      return baseURL;
    }

    if (/^(https?:)?\/\//.test(baseURL)) {
      return baseURL;
    }

    baseURL = location.origin + (!/^\//.test(baseURL) ? '/' : '') + baseURL;

    return baseURL;
  }

  function newWindowOpenFn() {
    const openWndArguments = arguments;
    let useOriginalOpenWnd = true;
    let generatedWindow = null;

    function getWindowName(openWndArguments) {
      const windowName = openWndArguments[1];
      if (windowName != null && !["_blank", "_parent", "_self", "_top"].includes(windowName)) {
        return windowName;
      }

      return null;
    }

    function copyMissingProperties(src, dest) {
      let prop;
      for (prop in src) {
        try {
          if (dest[prop] === undefined && src[prop]) {
            dest[prop] = src[prop];
          }
        } catch (e) {}
      }
      return dest;
    }

    function isParentWindow() {
      try {
        return !!(parent.Window && capturingElement instanceof parent.Window);
      } catch (e) {
        return false;
      }
    }

    function isOverlayish(el) {
      let style = el && el.style;

      if (style && /fixed|absolute/.test(style.position) && el.offsetWidth >= winWidth * 0.6 && el.offsetHeight >= winHeight * 0.75) {
        return true;
      }

      return false;
    }

    let capturingElement = null; // the element who registered to the event
    let srcElement = null; // the clicked on element
    let closestParentLink = null;

    if (window.event != null) {
      capturingElement = window.event.currentTarget;
      srcElement = window.event.srcElement;
    }

    if (srcElement != null && srcElement instanceof HTMLElement) {
      closestParentLink = srcElement.closest('a');

      if (closestParentLink && closestParentLink.href) {
        openWndArguments[3] = closestParentLink.href;
      }
    }

    //callee will not work in ES6 or stict mode
    try {
      const callers = [];
      if (capturingElement == null) {
        let caller = openWndArguments.callee;

        while (caller.arguments != null && caller.arguments.callee.caller != null && callers.indexOf(caller.arguments.callee.caller) == -1) {
          caller = caller.arguments.callee.caller;

          callers.push(caller);
        }

        if (caller.arguments != null && caller.arguments.length > 0 && caller.arguments[0].currentTarget != null) {
          capturingElement = caller.arguments[0].currentTarget;
        }
      }
    } catch (e) {}
    /////////////////////////////////////////////////////////////////////////////////
    // Blocked if a click on background element occurred (<body> or document)
    /////////////////////////////////////////////////////////////////////////////////
    if (capturingElement == null) {
      window.pbreason = 'Blocked a new window opened without any user interaction';
      useOriginalOpenWnd = false;
    } else if (capturingElement != null && (capturingElement instanceof Window || isParentWindow(capturingElement) || capturingElement === document || capturingElement.URL != null && capturingElement.body != null || capturingElement.nodeName != null && (capturingElement.nodeName.toLowerCase() == "body" || capturingElement.nodeName.toLowerCase() == "document"))) {
      window.pbreason = `Blocked a new window opened with URL: ${openWndArguments[0]} because it was triggered by the ${capturingElement.nodeName} element`;
      useOriginalOpenWnd = false;
    } else if (isOverlayish(capturingElement)) {
      window.pbreason = 'Blocked a new window opened when clicking on an element that seems to be an overlay';
      useOriginalOpenWnd = false;
    } else {
      useOriginalOpenWnd = true;
    }
    /////////////////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////////////////
    // Block if a full screen was just initiated while opening this url.
    /////////////////////////////////////////////////////////////////////////////////

    const fullScreenElement = document.webkitFullscreenElement || document.mozFullscreenElement || document.fullscreenElement;
    if (new Date().getTime() - fullScreenOpenTime < 1000 || isNaN(fullScreenOpenTime) && isDocumentInFullScreenMode()) {

      window.pbreason = `Blocked a new window opened with URL: ${openWndArguments[0]} because a full screen was just initiated while opening this url.`;

      /* JRA REMOVED
       if (window[script_params.fullScreenFnKey]) {
       window.clearTimeout(window[script_params.fullScreenFnKey]);
       }
       */

      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      }

      useOriginalOpenWnd = false;
    }
    /////////////////////////////////////////////////////////////////////////////////
    let openUrl = openWndArguments[0];
    let inWhitelist = isInWhitelist(openUrl);

    if (inWhitelist) {
      useOriginalOpenWnd = true;
    } else if (isInBlacklist(openUrl)) {
      useOriginalOpenWnd = false;
    }

    if (useOriginalOpenWnd == true) {
      generatedWindow = originalWindowOpenFn.apply(this, openWndArguments);
      // save the window by name, for latter use.
      let windowName = getWindowName(openWndArguments);
      if (windowName != null) {
        windowsWithNames[windowName] = generatedWindow;
      }

      // 2nd line of defence: allow window to open but monitor carefully...

      /////////////////////////////////////////////////////////////////////////////////
      // Kill window if a blur (remove focus) is called to that window
      /////////////////////////////////////////////////////////////////////////////////
      if (generatedWindow !== window) {
        const openTime = new Date().getTime();
        const originalWndBlurFn = generatedWindow.blur;
        generatedWindow.blur = () => {
          if (new Date().getTime() - openTime < 1000 && !inWhitelist /* one second */) {
              window.pbreason = `Blocked a new window opened with URL: ${openWndArguments[0]} because a it was blured`;
              generatedWindow.close();
              blockedWndNotification(openWndArguments);
            } else {
            originalWndBlurFn();
          }
        };
      }
      /////////////////////////////////////////////////////////////////////////////////
    } else {
      // (useOriginalOpenWnd == false)
      const location = {
        href: openWndArguments[0]
      };

      location.replace = url => {
        location.href = url;
      };

      generatedWindow = {
        close() {
          return true;
        },
        test() {
          return true;
        },
        blur() {
          return true;
        },
        focus() {
          return true;
        },
        showModelessDialog() {
          return true;
        },
        showModalDialog() {
          return true;
        },
        prompt() {
          return true;
        },
        confirm() {
          return true;
        },
        alert() {
          return true;
        },
        moveTo() {
          return true;
        },
        moveBy() {
          return true;
        },
        resizeTo() {
          return true;
        },
        resizeBy() {
          return true;
        },
        scrollBy() {
          return true;
        },
        scrollTo() {
          return true;
        },
        getSelection() {
          return true;
        },
        onunload() {
          return true;
        },
        print() {
          return true;
        },
        open() {
          return this;
        },
        opener: window,
        closed: false,
        innerHeight: 480,
        innerWidth: 640,
        name: openWndArguments[1],
        location,
        document: { location }
      };

      copyMissingProperties(window, generatedWindow);

      generatedWindow.window = generatedWindow;

      let windowName = getWindowName(openWndArguments);
      if (windowName != null) {
        try {
          // originalWindowOpenFn("", windowName).close();
          windowsWithNames[windowName].close();
        } catch (err) {}
      }

      let fnGetUrl = function () {
        let url;
        if (!(generatedWindow.location instanceof Object)) {
          url = generatedWindow.location;
        } else if (!(generatedWindow.document.location instanceof Object)) {
          url = generatedWindow.document.location;
        } else if (location.href != null) {
          url = location.href;
        } else {
          url = openWndArguments[0];
        }
        openWndArguments[0] = url;

        blockedWndNotification(openWndArguments);
      };

      //why set timeout?  if anyone finds a reason for it, please write it here
      //in iframes it makes problems so i'm avoiding it there
      if (top == self) {
        setTimeout(fnGetUrl, 100);
      } else {
        fnGetUrl();
      }
    }

    return generatedWindow;
  }

  function pbWindowOpen() {
    try {
      return newWindowOpenFn.apply(this, arguments);
    } catch (err) {
      return null;
    }
  }

  /////////////////////////////////////////////////////////////////////////////////
  // Replace the window open method with Poper Blocker's
  /////////////////////////////////////////////////////////////////////////////////
  window.open = pbWindowOpen;
  /////////////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Monitor dynamic html element creation to prevent generating <a> elements with click dispatching event
  //////////////////////////////////////////////////////////////////////////////////////////////////////////
  HTMLElement.prototype.appendChild = function () {
    const newElement = originalAppendChildFn.apply(this, arguments);

    if (newElement.nodeName == 'IFRAME' && newElement.contentWindow) {
      try {
        const s = document.createElement('script');s.textContent = injectedCode;
        const doc = newElement.contentWindow.document;

        (doc.head || doc.body).appendChild(s);
      } catch (e) {}
    }

    return newElement;
  };

  document.createElement = function (tagName) {
    const newElement = originalCreateElementFn.apply(document, arguments);

    if (tagName && tagName.toLowerCase() == 'a') {
      timeSinceCreateAElement = new Date().getTime();

      const originalClick = newElement.click;
      const originalDispatchEventFn = newElement.dispatchEvent;

      newElement.click = function (...args) {
        // We block when a element was created in code. However, when the element
        // has no href and no parents and no children, it should be safe to allow the click
        // (when element has parents, event propogates to them and then the block can be bypassed)
        if ((newElement.href || newElement.parentElement || newElement.children && newElement.children.length != 0) && !isInWhitelist(newElement.href)) {
          window.pbreason = "blocked due to an explicit dispatchEvent event with type 'click' on an 'a' tag";

          blockedWndNotification({ "0": newElement.href });

          return true;
        } else {
          originalClick.apply(this, args);
        }
      };

      newElement.dispatchEvent = function (event) {
        if (event.type != null && `${event.type}`.toLocaleLowerCase() == "click") {
          if (!isInWhitelist(newElement.href)) {
            window.pbreason = "blocked due to an explicit dispatchEvent event with type 'click' on an 'a' tag";

            blockedWndNotification({ "0": newElement.href });

            return true;
          }
        }

        return originalDispatchEventFn.call(this, event);
      };

      lastCreatedAElement = newElement;
    }

    if (tagName && tagName.toLowerCase() == 'iframe') {
      const _src = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(newElement), 'src');

      Object.defineProperty(newElement, 'src', {
        set(src) {
          let splitted,
              newSrc = src.replace(/\s/g, ''); // trim spaces
          if (/data:text\/html/.test(newSrc)) {
            const base64 = 'base64,';
            const utf8 = 'charset=utf-8,';
            const code = `<s\cript>${injectedCode}</s\cript>`;

            if (newSrc.indexOf(base64) !== -1) {
              splitted = newSrc.split(base64);
              newSrc = splitted[0] + base64 + btoa(code + atob(splitted[1]));
            } else if (newSrc.indexOf(utf8) !== -1) {
              splitted = newSrc.split(utf8);
              newSrc = splitted[0] + utf8 + encodeURI(code + decodeURI(splitted[1]));
            }
          }
          _src.set.apply(newElement, [newSrc]);
        }
      });
    }

    return newElement;
  };

  /////////////////////////////////////////////////////////////////////////////////


  /////////////////////////////////////////////////////////////////////////////////
  // Block artificial mouse click on frashly created <a> elements
  /////////////////////////////////////////////////////////////////////////////////
  document.createEvent = function () {
    try {
      if (arguments[0].toLowerCase().includes("mouse") && new Date().getTime() - timeSinceCreateAElement <= 50) {
        let openUrlDomain, topUrl, topDomain;

        try {
          openUrlDomain = new URL(lastCreatedAElement.href).hostname;
        } catch (e) {}

        try {
          topUrl = window.location != window.parent.location ? document.referrer : document.location.href;
        } catch (e) {}

        try {
          topDomain = new URL(topUrl).hostname;
        } catch (e) {}

        //block if the origin is not same
        let isSelfDomain = openUrlDomain == topDomain;

        if (lastCreatedAElement.href.trim() && !isInWhitelist(lastCreatedAElement.href) && !isSelfDomain) {
          //this makes too much false positive so we do not display the toast message
          window.pbreason = `Blocked because 'a' element was recently created and ${arguments[0]} event was created shortly after`;
          arguments[0] = lastCreatedAElement.href;

          blockedWndNotification({ "0": lastCreatedAElement.href });

          return {
            type: 'click',
            initMouseEvent: function () {}
          };
        }
      }

      return originalCreateEventFn.apply(document, arguments);
    } catch (err) {}
  };
  /////////////////////////////////////////////////////////////////////////////////


  /////////////////////////////////////////////////////////////////////////////////
  // Monitor full screen requests
  /////////////////////////////////////////////////////////////////////////////////
  function onFullScreen(isInFullScreenMode) {
    if (isInFullScreenMode) {
      fullScreenOpenTime = new Date().getTime();
    } else {
      fullScreenOpenTime = NaN;
    }
  }

  /////////////////////////////////////////////////////////////////////////////////

  function isDocumentInFullScreenMode() {
    // Note that the browser fullscreen (triggered by short keys) might
    // be considered different from content fullscreen when expecting a boolean
    return document.fullScreenElement && document.fullScreenElement !== null || // alternative standard methods
    document.mozFullscreenElement != null || document.webkitFullscreenElement != null; // current working methods
  }

  function isInWhitelist(url) {
    return isInList(url, pb_whitelist);
  }

  function isInBlacklist(url) {
    return isInList(url, pb_blacklist);
  }

  function isInList(url, list) {
    if (list) {
      return list.some(li => {
        return new RegExp("https?://(www\.|.*\.)?" + li + "+").test(url);
      });
    } else {
      return false;
    }
  }

  function blockedWndNotification(openWndArguments) {
    //this is to prevent a site that "stuck" on trying to open a new window to send endless calls to the extension
    if (!lastBlockTime || lastBlockTime < Date.now() - 1000) {
      openWndArguments["0"] = getAbsoluteURL(openWndArguments["0"]);

      parentRef.postMessage({ type: "blockedWindow", args: JSON.stringify(openWndArguments) }, '*');
    }

    lastBlockTime = Date.now();
  }

  function executeCommand(commandId, messageId) {
    if (messageId == pb_message) {
      switch (commandId) {
        case 0:
          //off
          window.open = originalWindowOpenFn;
          document.createElement = originalCreateElementFn;
          document.createEvent = originalCreateEventFn;
          HTMLElement.prototype.appendChild = originalAppendChildFn;
          break;

        case 1:
          //allow once
          break;
      }
    }
  }

  document.addEventListener("fullscreenchange", () => {
    onFullScreen(document.fullscreen);
  }, false);

  document.addEventListener("mozfullscreenchange", () => {
    onFullScreen(document.mozFullScreen);
  }, false);

  document.addEventListener("webkitfullscreenchange", () => {
    onFullScreen(document.webkitIsFullScreen);
  }, false);

  (function () {
    window.pbExternalCommand = function (commandId, messageId) {
      executeCommand(commandId, messageId);
    };
  })();
};
    inject();
  })();</script></head><body></body></html>